# API 接口开放平台

[项目地址](https://gitee.com/NingWest/api-interface-open-platform.git)



背景：

1. 前端开发需要用到后端接口
2. 要用现成的接口



做一个API接口平台：

1. 防止攻击（安全性）
2. 不能随便调用（限制、开通）
3. 调用次数
4. 计费
5. 流量保护
6. API接入



## 项目介绍

做一个提供API接口调用的平台，用户可以注册登录，开通接口调用权限。用户可以使用接口，并且每次调用会进行统计。管理员可以发布接口、下线接口、接入接口，以及可视化接口的调用情况、数据。



> x项目流程图

<img src="文档.assets/image-20230501171825813.png" alt="image-20230501171825813" style="zoom:80%;" />





## 技术选型



### 前端

Ant Design Pro

React

Ant Design Procomponents

Umi

Umi Requset (Axios 的封装)



### 后端

java Spring boot

Spring Boot Starter (SDK 开发)

？？？（网关、限流、日志实现）









## 项目分期



### 初始化和展示

项目介绍、设计、技术选型

基础项目的搭建

接口管理

用户查看接口

### 接口调用

1. 开发模拟API接口
2. 开发调用这个接口的代码
3. 保证调用的安全性（API签名认证）
4. 客户端 SDK 的开发
5. 管理员接口  **发布** 与调用
6. 接口文档展示、接口在线调用



### 接口计费与保护

统计用户调用次数

限流

计费

日志

开通



### 管理、统计分析

提供可视化平台，用图表的方式展示所有的接口的调用情况，便于调整业务。







# 第一部分



主要内容：antd 前端框架的整合，踩坑，openApi的使用





## Antd Pro 框架操作 & 踩坑

### 框架安装

```bash
npm i @ant-design/pro-cli -g
```

### 项目搭建

```bash
pro create 项目名称
```



### 移除国际化报错

> 错误一

```bash
// 报错 prettier
npm i eslint prettier-eslint eslint-config-prettier --save-dev
```



> 错误二

![image-20230502073449525](文档.assets/image-20230502073449525.png)



解决办法

[解决博客](https://blog.csdn.net/weixin_42425305/article/details/129445415?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129445415-blog-109546000.235%5Ev32%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129445415-blog-109546000.235%5Ev32%5Epc_relevant_default_base3)

![image-20230502074438076](文档.assets/image-20230502074438076.png)



```bash
npm i @typescript-eslint/eslint-plugin
npm i eslint-plugin-eslint-comments
npm i eslint-plugin-jest
npm i eslint-plugin-unicorn
```



<font color=red>成功解决</font>

解决后将原本的i18n目录删除  注意 看下面保存一下这个文件



#### 国际化遗留问题

![image-20230504065451009](文档.assets/image-20230504065451009.png)



可以将这个汉语的文件添加回来

![image-20230504070743083](文档.assets/image-20230504070743083.png)











### Antd 快速与后端增删改查对应

对应后端的 openApi 的地址接口，自动生成

<img src="文档.assets/image-20230504060919671.png" alt="image-20230504060919671" style="zoom:80%;" />



> 点击即可生成代码

![image-20230504061444106](文档.assets/image-20230504061444106.png)



注意：后端的controller上不要有  @Api(tags = "微信公众号相关接口")  注解  ，前端生成代码的文件名会显示这里面汉字的拼音。。。





### Antd 修改请求的配置

![image-20230504062240347](文档.assets/image-20230504062240347.png)



将原本的 requestErrorConfig 修改为 requestConfig 

![image-20230504062317774](文档.assets/image-20230504062317774.png)



在requestConfig中添加 基础地址



### 修改Antd框架的登录接口



> 登录逻辑修改

```tsx
const handleSubmit = async (values: API.UserLoginRequest) => {
    try {
      // 登录  修改为自己后端的登录接口
      const res = await userLoginUsingPOST({ ...values });
      if (res.data) {
        const urlParams = new URL(window.location.href).searchParams;
        history.push(urlParams.get('redirect') || '/');
        return;
      }
      // 如果失败去设置用户错误信息
      setUserLoginState(msg);
    } catch (error) {
      const defaultLoginFailureMessage = intl.formatMessage({
        id: 'pages.login.failure',
        defaultMessage: '登录失败，请重试！',
      });
      console.log(error);
      message.error(defaultLoginFailureMessage);
    }
  };
```



注意：将项目中的所有 的登录对应的参数都要换成自己的，例如登录参数的接受实体信息，antd框架的登录信息是 username，password，我们自己的是userAccount，userPassword，都要修改。



> 修改完毕之后登录即可使用，但是因为没有保存用户的登录态，还是无法进入信息页面

![image-20230504065055395](文档.assets/image-20230504065055395.png)





### Antd 保存用户的登录态



> 保存信息的方法

<img src="文档.assets/image-20230504071656686.png" alt="image-20230504071656686" style="zoom:80%;" />



> 保存信息的类型

![image-20230504071957439](文档.assets/image-20230504071957439.png)



> 登录完毕之后保存用户的登录信息

```tsx
  const handleSubmit = async (values: API.UserLoginRequest) => {
    try {
      // 登录  修改为自己后端的登录接口
      const res = await userLoginUsingPOST({ ...values });
      if (res.data) {
        const urlParams = new URL(window.location.href).searchParams;
        history.push(urlParams.get('redirect') || '/');
        // 登录  ------------------
        setInitialState({
          loginUser: res.data,
        });
        // -----------------------
        return;
      }
    } catch (error) {
      const defaultLoginFailureMessage = intl.formatMessage({
        id: 'pages.login.failure',
        defaultMessage: '登录失败，请重试！',
      });
      console.log(error);
      message.error(defaultLoginFailureMessage);
    }
  };
```



修改完毕之后，在登录即可跳转页面‘



> 刷新页面，跳转登录页的问题，修改这个方法

<img src="文档.assets/image-20230508162737206.png" alt="image-20230508162737206" style="zoom:80%;" />



> 这两个方法，这样写可行

<img src="文档.assets/image-20230508162932090.png" alt="image-20230508162932090" style="zoom:80%;" />







### Antd 处理角色问题

<img src="文档.assets/image-20230508224400450.png" alt="image-20230508224400450" style="zoom:80%;" />



> 修改代码

```jsx
export default function access(initialState: InitialState | undefined) {
  const {loginUser} = initialState ?? {};

  return {
    canAdmin: loginUser && loginUser.userRole === 'admin',
    canUser: loginUser && loginUser.userRole === 'user',
  };
}
```





### Antd 表格使用

<img src="文档.assets/image-20230508230230591.png" alt="image-20230508230230591" style="zoom:80%;" />



> 修改内容

```tsx
import {addRule, removeRule, updateRule} from '@/services/ant-design-pro/api';
import {PlusOutlined} from '@ant-design/icons';
import type {ActionType, ProColumns, ProDescriptionsItemProps} from '@ant-design/pro-components';
import {
  FooterToolbar,
  ModalForm,
  PageContainer,
  ProDescriptions,
  ProFormText,
  ProFormTextArea,
  ProTable,
} from '@ant-design/pro-components';
import {FormattedMessage, useIntl} from '@umijs/max';
import {Button, Drawer, message} from 'antd';
import React, {useRef, useState} from 'react';
import type {FormValueType} from './components/UpdateForm';
import UpdateForm from './components/UpdateForm';
import {listInterfaceInfoVOByPageUsingGET} from "@/services/api-frontend/interFaceInfoController";

/**
 * @en-US Add node
 * @zh-CN 添加节点
 * @param fields
 */

// 处理添加
const handleAdd = async (fields: API.RuleListItem) => {
  const hide = message.loading('正在添加');
  try {
    await addRule({...fields});
    hide();
    message.success('Added successfully');
    return true;
  } catch (error) {
    hide();
    message.error('Adding failed, please try again!');
    return false;
  }
};

/**
 * @en-US Update node
 * @zh-CN 更新节点
 *
 * @param fields
 */
// 修改
const handleUpdate = async (fields: FormValueType) => {
  const hide = message.loading('Configuring');
  try {
    await updateRule({
      name: fields.name,
      desc: fields.desc,
      key: fields.key,
    });
    hide();

    message.success('Configuration is successful');
    return true;
  } catch (error) {
    hide();
    message.error('Configuration failed, please try again!');
    return false;
  }
};

/**
 *  Delete node
 * @zh-CN 删除节点
 *
 * @param selectedRows
 */
// 删除
const handleRemove = async (selectedRows: API.RuleListItem[]) => {
  const hide = message.loading('正在删除');
  if (!selectedRows) return true;
  try {
    await removeRule({
      key: selectedRows.map((row) => row.key),
    });
    hide();
    message.success('Deleted successfully and will refresh soon');
    return true;
  } catch (error) {
    hide();
    message.error('Delete failed, please try again');
    return false;
  }
};

// 主题内容
const TableList: React.FC = () => {
  /**
   * @en-US Pop-up window of new window
   * @zh-CN 新建窗口的弹窗
   *  */
  const [createModalOpen, handleModalOpen] = useState<boolean>(false);
  /**
   * @en-US The pop-up window of the distribution update window
   * @zh-CN 分布更新窗口的弹窗
   * */
  const [updateModalOpen, handleUpdateModalOpen] = useState<boolean>(false);

  const [showDetail, setShowDetail] = useState<boolean>(false);

  const actionRef = useRef<ActionType>();
  const [currentRow, setCurrentRow] = useState<API.RuleListItem>();
  const [selectedRowsState, setSelectedRows] = useState<API.RuleListItem[]>([]);

  /**
   * @en-US International configuration
   * @zh-CN 国际化配置
   * */
  const intl = useIntl();

  const columns: ProColumns<API.InterfaceInfoVo>[] = [
    {
      title: "id",
      dataIndex: 'id',
      valueType: 'index',
    },
    {
      title: "接口名",
      dataIndex: 'name',
      valueType: 'text'
    },
    {
      title: "url",
      dataIndex: 'url',
      valueType: 'textarea',
    },
    {
      title: "请求类型",
      dataIndex: 'method',
      valueType: 'textarea',
    },
    {
      title: "创建人",
      dataIndex: 'userName',
      valueType: 'text'
    },
    {
      title: "响应头",
      dataIndex: 'responseHeader',
      valueType: 'textarea',
    },
    {
      title: "接口描述",
      dataIndex: 'description',
      valueType: 'textarea',
    },
    {
      title: "请求头",
      dataIndex: 'requestHeader',
      valueType: 'textarea',
    },
    {
      title: "接口状态",
      dataIndex: 'status',
      hideInForm: true,
      valueEnum: {
        0: {
          text: "关闭",
          status: 'Default',
        },
        1: {
          text: "开启",
          status: 'Processing',
        }
      },
    },
    {
      title: "创建时间",
      dataIndex: 'createTime',
      valueType: 'dateTime',
    },
    {
      title: "操作",
      dataIndex: 'option',
      valueType: 'option',
      render: (_, record) => [
        <a
          key="config"
          onClick={() => {
            handleUpdateModalOpen(true);
            setCurrentRow(record);
          }}
        >
          <FormattedMessage id="pages.searchTable.config" defaultMessage="Configuration"/>
        </a>,
        <a key="subscribeAlert" href="https://procomponents.ant.design/">
          <FormattedMessage
            id="pages.searchTable.subscribeAlert"
            defaultMessage="Subscribe to alerts"
          />
        </a>,
      ],
    },
  ];

  return (
    <PageContainer>
      <ProTable<API.RuleListItem, API.PageParams>
        headerTitle={intl.formatMessage({
          id: 'pages.searchTable.title',
          defaultMessage: 'Enquiry form',
        })}
        actionRef={actionRef}
        // key报错
        rowKey="id"
        search={{
          labelWidth: 120,
        }}
        toolBarRender={() => [
          <Button
            type="primary"
            key="primary"
            onClick={() => {
              handleModalOpen(true);
            }}
          >
            <PlusOutlined/> <FormattedMessage id="pages.searchTable.new" defaultMessage="New"/>
          </Button>,
        ]}
        // 更改自己获取数据的方法
        // @ts-ignore
        request={async (params) => {
          let res = await listInterfaceInfoVOByPageUsingGET({
            ...params
          })
          if (res.data) {
            return {
              data: res.data?.reconds || [],
              success: true,
              total: res.data.total,
            }
          }
        }}
        columns={columns}
        rowSelection={{
          onChange: (_, selectedRows) => {
            setSelectedRows(selectedRows);
          },
        }}
      />
      {selectedRowsState?.length > 0 && (
        <FooterToolbar
          extra={
            <div>
              <FormattedMessage id="pages.searchTable.chosen" defaultMessage="Chosen"/>{' '}
              <a style={{fontWeight: 600}}>{selectedRowsState.length}</a>{' '}
              <FormattedMessage id="pages.searchTable.item" defaultMessage="项"/>
              &nbsp;&nbsp;
              <span>
                <FormattedMessage
                  id="pages.searchTable.totalServiceCalls"
                  defaultMessage="Total number of service calls"
                />{' '}
                {selectedRowsState.reduce((pre, item) => pre + item.callNo!, 0)}{' '}
                <FormattedMessage id="pages.searchTable.tenThousand" defaultMessage="万"/>
              </span>
            </div>
          }
        >
          <Button
            onClick={async () => {
              await handleRemove(selectedRowsState);
              setSelectedRows([]);
              actionRef.current?.reloadAndRest?.();
            }}
          >
            <FormattedMessage
              id="pages.searchTable.batchDeletion"
              defaultMessage="Batch deletion"
            />
          </Button>
          <Button type="primary">
            <FormattedMessage
              id="pages.searchTable.batchApproval"
              defaultMessage="Batch approval"
            />
          </Button>
        </FooterToolbar>
      )}
      <ModalForm
        title={intl.formatMessage({
          id: 'pages.searchTable.createForm.newRule',
          defaultMessage: 'New rule',
        })}
        width="400px"
        open={createModalOpen}
        onOpenChange={handleModalOpen}
        onFinish={async (value) => {
          const success = await handleAdd(value as API.RuleListItem);
          if (success) {
            handleModalOpen(false);
            if (actionRef.current) {
              actionRef.current.reload();
            }
          }
        }}
      >
        <ProFormText
          rules={[
            {
              required: true,
              message: (
                <FormattedMessage
                  id="pages.searchTable.ruleName"
                  defaultMessage="Rule name is required"
                />
              ),
            },
          ]}
          width="md"
          name="name"
        />
        <ProFormTextArea width="md" name="desc"/>
      </ModalForm>
      <UpdateForm
        onSubmit={async (value) => {
          const success = await handleUpdate(value);
          if (success) {
            handleUpdateModalOpen(false);
            setCurrentRow(undefined);
            if (actionRef.current) {
              actionRef.current.reload();
            }
          }
        }}
        onCancel={() => {
          handleUpdateModalOpen(false);
          if (!showDetail) {
            setCurrentRow(undefined);
          }
        }}
        updateModalOpen={updateModalOpen}
        values={currentRow || {}}
      />

      <Drawer
        width={600}
        open={showDetail}
        onClose={() => {
          setCurrentRow(undefined);
          setShowDetail(false);
        }}
        closable={false}
      >
        {currentRow?.name && (
          <ProDescriptions<API.RuleListItem>
            column={2}
            title={currentRow?.name}
            request={async () => ({
              data: currentRow || {},
            })}
            params={{
              id: currentRow?.name,
            }}
            columns={columns as ProDescriptionsItemProps<API.RuleListItem>[]}
          />
        )}
      </Drawer>
    </PageContainer>
  );
};

export default TableList;

```



> 获取数据

```tsx
request={rule}
```

请求数据的接口



### key报错问题

<img src="文档.assets/image-20230509072614949.png" alt="image-20230509072614949" style="zoom:80%;" />



<img src="文档.assets/image-20230509072749508.png" alt="image-20230509072749508" style="zoom:80%;" />



> 解决办法

```
rowKey="id"
```



### 路由修改

<img src="文档.assets/image-20230509081756585.png" alt="image-20230509081756585" style="zoom:80%;" />



对应组件的名称





### Antd模态框

> 封装组件

```tsx
 <CreateForm
    open={createModalOpen}
    columns={columns}
    // 关闭
    onCancel={() => {
      // 关闭模态框
      handleModalOpen(false)
    }}
    onSubmit={async (value) => {
      const success = await handleAdd(value);
      if (success) {
        handleUpdateModalOpen(false);
        setCurrentRow(undefined);
        if (actionRef.current) {
          actionRef.current.reload();
        }
      }
    }}
  />
```

> 组件内部

```tsx
import {ProColumns, ProTable,} from '@ant-design/pro-components';
import React from 'react';
import {Modal} from "antd";

export type Props = {
  // 将列全部传递过来
  columns: ProColumns<API.InterfaceInfoVo>[],
  onCancel: () => void;
  // @ts-ignore
  onSubmit: (values: API.InterFaceInfo) => Promise<void>;
  open: boolean;
};

const CreateFrom: React.FC<Props> = (props) => {
  const {open, onCancel, onSubmit, columns} = props
  return (
    <Modal open={open} onCancel={() => onCancel?.()}>
      <ProTable
        type="form"
        columns={columns}
        onSubmit={async (value) => {
          onSubmit?.(value)
        }}
      />
    </Modal>
  )
};

export default CreateFrom;
```



### Antd不展示某行

>  hideInForm  不展示某行

```tsx
{
  title: "创建时间",
  dataIndex: 'createTime',
  valueType: 'dateTime',
  hideInForm: true
},
```



### Antd设置规则

formItemProps

```tsx
{
  title: "接口名",
  dataIndex: 'name',
  valueType: 'text',
  formItemProps: {
    rules: [{
      required: true,
      message: '接口名必须填写！'
    }]
  }
},
```



### Antd 设置表格

> footer={null} 

```tsx
<Modal footer={null} open={open} onCancel={() => onCancel?.()}>
  <ProTable
    type="form"
    columns={columns}
    onSubmit={async (value) => {
      onSubmit?.(value)
    }}
  />
</Modal>
```

<img src="文档.assets/image-20230509144419805.png" alt="image-20230509144419805" style="zoom:80%;" />



### 修改接口无法获取id问题？

> 问题描述？

在下面的方法中，在这个fields 中无法获取 id ？**我看了又看，两眼一抹黑**，自己想了个办法  从 currentRow 中获取 id，

```tsx
const handleUpdate = async (fields: API.InterfaceInfoVo) => {
    const hide = message.loading('修改中。');
    try {
      // @ts-ignore
      await updateInterfaceInfoUsingPOST({...fields, id: currentRow?.id});
      hide();
      message.success('操作成功');
      return true;
    } catch (error: any) {
      hide();
      message.error('操作失败' + error.message);
      return false;
    }
  };
```









## 项目模块设计分析



### 接口信息表

id

name 接口名称

description 描述

url 接口地址

type 请求类型

requestHeader 请求头

responseHeader 响应头

status 接口状态 （0 关闭  1 开启）

 

isDelete 

createTime

updateTime



```sql
-- 接口信息表
create table if not exists interface_info
(
    id             bigint auto_increment comment 'id' primary key,

    name           int comment '接口名称',
    description    varchar(512)                         null comment '接口描述',
    url            varchar(512)                         not null comment '接口地址',
    method         varchar(20)                          not null comment '请求类型',
    requestHeader  text                                 null comment '请求头',
    responseHeader text                                 null comment '响应头',
    status         tinyint(1) default 0                 not null comment '接口状态（0 关闭 1 开启）',


    userId         bigint                               not null comment '创建人id',
    userName       varchar(20)                          not null comment '创建人姓名',
    createTime     datetime   default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime     datetime   default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete       tinyint    default 0                 not null comment '是否删除'
) comment '接口信息表';
```



### 接口后端代码 - controller



```java
/**
 * 接口请求类型
 */
@RestController
@RequestMapping("/interfaceInfo")
@Slf4j
@Api(tags = "接口请求管理")
public class InterFaceInfoController {

    @Resource
    private InterfaceinfoService interfaceInfoService;


    @Resource
    private UserService userService;

    // region 增删改查

    /**
     * 创建
     */
    @PostMapping("/add")
    public BaseResponse<Long> addInterfaceInfo(@Validated @RequestBody InterfaceInfoAddRequest addRequest, HttpServletRequest request) {

        interfaceInfoService.add(addRequest, request);

        return ResultUtils.success();
    }

    /**
     * 删除
     */
    @PostMapping("/delete")
    public BaseResponse<Boolean> deleteInterfaceInfo(@RequestBody DeleteRequest deleteRequest, HttpServletRequest request) {
        if (deleteRequest == null || deleteRequest.getId() <= 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User user = userService.getLoginUser(request);
        long id = deleteRequest.getId();
        // 判断是否存在
        InterfaceInfo oldInterfaceInfo = interfaceInfoService.getById(id);
        ThrowUtils.throwIf(oldInterfaceInfo == null, ErrorCode.NOT_FOUND_ERROR);
        // 仅本人或管理员可删除
        if (!oldInterfaceInfo.getUserId().equals(user.getId()) && !userService.isAdmin(request)) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
        }
        boolean b = interfaceInfoService.removeById(id);
        return ResultUtils.success(b);
    }

    /**
     * 更新（仅管理员）
     */
    @PostMapping("/update")
    @AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
    public BaseResponse<Boolean> updateInterfaceInfo(@Validated @RequestBody InterfaceInfoUpdateRequest interfaceInfoUpdateRequest) {
        if (interfaceInfoUpdateRequest == null || interfaceInfoUpdateRequest.getId() <= 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        Boolean result = interfaceInfoService.upt(interfaceInfoUpdateRequest);

        return ResultUtils.success(result);
    }

    /**
     * 根据 id 获取
     */
    @GetMapping("/get/vo")
    public BaseResponse<InterfaceInfoVo> getInterfaceInfoVOById(long id, HttpServletRequest request) {
        if (id <= 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        InterfaceInfo interfaceInfo = interfaceInfoService.getById(id);
        if (interfaceInfo == null) {
            throw new BusinessException(ErrorCode.NOT_FOUND_ERROR);
        }
        InterfaceInfoVo interfaceInfoVo = BeanCopyUtil.copyBean(interfaceInfo, InterfaceInfoVo.class);
        return ResultUtils.success(interfaceInfoVo);
    }

    /**
     * 分页获取列表（封装类）
     */
    @PostMapping("/list/page/vo")
    public BaseResponse<PageVo> listInterfaceInfoVOByPage(@RequestBody InterfaceInfoQueryRequest dto) {
        // 限制爬虫
        ThrowUtils.throwIf(dto.getPageSize() > 20, ErrorCode.PARAMS_ERROR);

        Page<InterfaceInfo> pageInfo = interfaceInfoService.selectPage(dto);

        PageVo pageVo = new PageVo();
        pageVo.setCurrent(pageInfo.getCurrent());
        pageVo.setSize(pageInfo.getSize());
        pageVo.setReconds(pageInfo.getRecords());
        pageVo.setTotal(pageInfo.getTotal());

        return ResultUtils.success(pageVo);
    }

}

```



### 前端对接后端的代码 - openApi 生成

![image-20230509062558070](文档.assets/image-20230509062558070.png)

```tsx
openAPI: [
{
  requestLibPath: "import { request } from '@umijs/max'",
  schemaPath: 'http://localhost:8102/api/v3/api-docs',
  projectName: 'api-frontend',
},
```



> 点击即可

![image-20230509062647951](文档.assets/image-20230509062647951.png)







# 第二部分



## 模拟接口项目

主旨：模拟接口（类似第三方的接口，进行调用）



搭建一个新的项目

<img src="文档.assets/image-20230509205854039.png" alt="image-20230509205854039" style="zoom:80%;" />





## 调用接口

几种HTTP 调用方式：

1. HttpClient
2. RestTemplate
3. 第三方库（OKHTTP、[Hutool](https://www.hutool.cn/)）



###  Hutool 使用

依赖引入

```xml
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.16</version>
</dependency>
```



> 使用

```java
import cn.hutool.http.HttpRequest;
import cn.hutool.http.HttpUtil;
import cn.hutool.json.JSON;
import cn.hutool.json.JSONUtil;
import com.ning.demo.model.User;

import java.util.HashMap;

/**
 * @author NingWest
 * @date 2023/05/09 21:17
 */
public class MyClient {

    public String getMyName() {

        //可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中
        HashMap<String, Object> paramMap = new HashMap<>();
        paramMap.put("name", "123");

        String result = HttpUtil.get("http://localhost:8103/api/demo", paramMap);
        System.out.println(result);
        return result;
    }

    public String postMyName() {

        //可以单独传入http参数，这样参数会自动做URL编码，拼接在URL中
        HashMap<String, Object> paramMap = new HashMap<>();
        paramMap.put("name", "123");

        String result = HttpUtil.post("http://localhost:8103/api/demo", paramMap);
        System.out.println(result);
        return result;
    }

    public String postJsonName(User user) {
        String jsonStr = JSONUtil.toJsonStr(user);
        return HttpRequest.post("http://localhost:8103/api/demo/user").body(jsonStr).execute().body();
    }

    public static void main(String[] args) {
        MyClient myClient = new MyClient();

        String myName = myClient.getMyName();
        System.out.println(myName);
        String s = myClient.postMyName();
        System.out.println(s);
        User user = new User();
        user.setName("ning");
        String jsonUser = myClient.postJsonName(user);
        System.out.println(jsonUser);

    }
}
```



## API签名认证

> 本质：

1. 签发签名
2. 使用签名（检验签名）



为什么需要？ 保证安全性。



> 怎么实现？

**参数一：**accessKey : 调用的标识 userA,userB  

**参数二：**secretKey：密钥  （复杂、无序、无规律）该参数不妨到请求头中

（类似用户名和密码，区别：ak、sk是无状态的）



密钥不可直接在服务器之间传递，有可能会别拦截

**参数三：**sign



加密方式：对称加密、非对称加密、md5签名（不可解密）

签名认证算法与

用户参数 + 密钥 =》 签名算法 =》 不可解密的值



服务器用一模一样的参数和算法去生成签名，只要和用户传的一致，就表示一致。



### 注意问题：请求重放问题

**参数4：**加入nonce随机数，只能用一次

服务端要保存用过的随机数

**参数5：**加 timestamp时间戳，校验时间戳是否过期。 



**参数6**：用户自己的请求参数





## 具体实现



用户表添加字段

先添加假数据，后期提供接口



> 校验参数的

```java
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.util.StrUtil;
import com.ning.demo.constant.Constant;
import com.ning.demo.model.User;
import com.ning.demo.utils.Md5Utils;
import com.ning.demo.utils.SignUtils;

import javax.servlet.http.HttpServletRequest;
import java.util.Date;
import java.util.Map;

/**
 * @author NingWest
 * @date 2023/05/10 11:14
 */
public class CheckCore {

    public static boolean checkParams(User user, HttpServletRequest request) {
        String sign = request.getHeader(Constant.SIGN);
        String nonce = request.getHeader(Constant.NONCE);
        String accessKey = request.getHeader(Constant.ACCESS_KEY);
        String timestamp = request.getHeader(Constant.TIMESTAMP);

        //先判断时间戳、随机数是否正确
        // 时间戳
        Date now = new Date();
        // 现在时间戳
        long nowTime = now.getTime();
        // 根据当前时间 获取两天前的时间戳
        long time = DateUtil.offsetDay(now, -2).getTime();
        // 如果传递过来的时间在这个范围内就证明是合法的时间请求
        if (StrUtil.isNotBlank(timestamp)) {
            // 转换为时间戳
            long timeStamp = Long.parseLong(timestamp);
            // 如果时间小于当前时间 并且大于 倒退2天 时间合理
            if (timeStamp >= nowTime || timeStamp < time) {
                return false;
            }
        }
        // todo nonce  此处的随机数 可以在生成的时候存入 redis 并携带过来唯一的UUID 根据 request获取
        if (StrUtil.isBlank(nonce)) {
            return false;
        }

        // todo 此处的 secretKey 应该是从数据库获取
        String newSign = Md5Utils.md5(user + "abcdefg" + accessKey);
        if (!newSign.equals(sign)) {
            return false;
        }

        // 最终无异常返回
        return true;
    }
}
```



> 客户端

```java
import cn.hutool.core.util.RandomUtil;
import cn.hutool.http.HttpRequest;
import cn.hutool.http.HttpUtil;
import cn.hutool.json.JSON;
import cn.hutool.json.JSONUtil;
import com.ning.demo.model.User;
import com.ning.demo.utils.Md5Utils;
import com.ning.demo.utils.SignUtils;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * @author NingWest
 * @date 2023/05/09 21:17
 */
public class MyClient {

    private String accessKey;

    private String secretKey;

    public MyClient() {
    }

    public MyClient(String accessKey, String secretKey) {
        this.accessKey = accessKey;
        this.secretKey = secretKey;
    }
    
    public String postJsonName(User user) {

        String jsonStr = JSONUtil.toJsonStr(user);
        return
                HttpRequest.post("http://localhost:8103/api/demo/user")
                        .addHeaders(SignUtils.getHeader(accessKey, secretKey, user))
                        .body(jsonStr)
                        .execute()
                        .body();
    }


    public static void main(String[] args) {
        MyClient myClient = new MyClient("ning", "abcde");
        User user = new User();
        user.setName("宁西");
        String jsonUser = myClient.postJsonName(user);
        System.out.println(jsonUser);


    }

}
```









### 后期想法

todo

自己实现签名等等的实现







